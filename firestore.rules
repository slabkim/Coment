rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    match /titles/{titleId} {
      allow read: if true;
      allow write: if false;
    }

    match /users/{userId} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null && request.auth.uid == userId;
    }

    match /titles/{titleId}/reviews/{reviewId} {
      allow read: if true;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    match /favorites/{favoriteId} {
      // Allow read for all authenticated users (for public profile showcase)
      allow read: if request.auth != null;
      // Only allow delete by owner
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
    }

    match /comments/{commentId} {
      allow read: if true;
      allow create: if request.auth != null;
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
      allow update: if request.auth != null && (
        request.auth.uid == resource.data.userId ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['replyCount', 'likeCount', 'replies'])
      );
    }

    match /comment_likes/{likeId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
      allow update: if false;
    }
    
    match /notifications/{notificationId} {
      // Allow read if user is the recipient or sender
      allow read: if request.auth != null && (
        request.auth.uid == resource.data.recipientUid ||
        request.auth.uid == resource.data.userId
      );
      // Anyone can create notifications (for mentions, etc.)
      allow create: if request.auth != null;
      // Allow update if user is the recipient (to mark as read) or Cloud Function (to mark as sent)
      allow update: if request.auth != null && (
        request.auth.uid == resource.data.recipientUid ||
        request.auth.uid == resource.data.userId ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['sent', 'sentAt', 'read', 'readAt'])
      );
      // Allow delete if user is the recipient
      allow delete: if request.auth != null && (
        request.auth.uid == resource.data.recipientUid ||
        request.auth.uid == resource.data.userId
      );
    }

    match /reading_status/{statusId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    match /follows/{followId} {
      allow read: if request.auth != null && (
        request.auth.uid == resource.data.followerId || 
        request.auth.uid == resource.data.followingId
      );
      allow create: if request.auth != null && request.resource.data.followerId == request.auth.uid;
      allow update: if request.auth != null && request.auth.uid == resource.data.followerId;
      allow delete: if request.auth != null && request.auth.uid == resource.data.followerId;
    }

    match /chats/{chatId} {
      // Allow read if user is authenticated AND is a participant
      // For new chats that don't exist yet, allow read if user ID is in chatId format
      allow read: if request.auth != null && (
        // Document exists and user is participant
        (resource != null && request.auth.uid in resource.data.participants) ||
        // Document doesn't exist yet but user ID matches chatId format (uid1_uid2 or uid2_uid1)
        (resource == null && (
          chatId.matches('.*_' + request.auth.uid + '$') ||
          chatId.matches('^' + request.auth.uid + '_.*')
        ))
      );
      // Allow create if user is in participants array
      allow create: if request.auth != null && request.auth.uid in request.resource.data.participants;
      // Allow update if user is participant
      allow update: if request.auth != null && (
        resource != null && request.auth.uid in resource.data.participants
      );
      allow delete: if false;
    }

    match /chat_messages/{messageId} {
      // For queries: allow read if user is authenticated
      // The chat document check will be done at application level
      // Note: Using get() in query rules doesn't work well, so we simplify
      allow read: if request.auth != null;
      
      // For create: check that user is sender and participant in chat
      allow create: if request.auth != null && 
        request.resource.data.senderId == request.auth.uid &&
        request.auth.uid in get(/databases/$(database)/documents/chats/$(request.resource.data.chatId)).data.participants;
      allow update: if request.auth != null && request.auth.uid == resource.data.senderId;
      allow delete: if false;
    }

    match /chat_history/{historyId} {
      // historyId format is "{chatId}_{userId}"
      // Allow read if:
      // 1. It's the user's own history (historyId ends with their userId)
      // 2. OR if user is authenticated (we'll filter at app level for security)
      // For new documents that don't exist yet, allow read if user ID matches
      allow read: if request.auth != null && (
        historyId.matches('.*_' + request.auth.uid + '$') ||
        (resource != null && request.auth.uid == resource.data.userId) ||
        // Allow read if user ID is in chatId (format: uid1_uid2_userId)
        (resource == null && (
          historyId.matches('.*_' + request.auth.uid + '$') ||
          historyId.matches('.*_' + request.auth.uid + '_.*')
        ))
      );
      // Allow create/update only for own history
      allow create: if request.auth != null && (
        historyId.matches('.*_' + request.auth.uid + '$') &&
        request.resource.data.userId == request.auth.uid
      );
      allow update: if request.auth != null && (
        historyId.matches('.*_' + request.auth.uid + '$') ||
        (resource != null && request.auth.uid == resource.data.userId)
      );
      allow delete: if false;
    }

    match /user_recommendations/{recommendationId} {
      allow read: if request.auth != null && (
        request.auth.uid == resource.data.fromUserId || 
        request.auth.uid == resource.data.toUserId
      );
      allow create: if request.auth != null && request.resource.data.fromUserId == request.auth.uid;
      allow update: if request.auth != null && request.auth.uid == resource.data.toUserId;
      allow delete: if request.auth != null && request.auth.uid == resource.data.fromUserId;
    }


    // FORUMS (User-Created Forums - Free Topic)
    match /forums/{forumId} {
      allow read: if true; // Anyone can read forum info
      allow create: if request.auth != null; // Any logged-in user can create
      allow update: if request.auth != null && (
        request.auth.uid in resource.data.moderatorIds ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberCount', 'messageCount', 'lastMessageAt', 'lastMessageText', 'lastMessageUser', 'moderatorIds', 'pinnedMessageIds'])
      );
      // Delete: creator or anyone in moderatorIds can delete (developer auto-added as moderator)
      allow delete: if request.auth != null && (
        request.auth.uid == resource.data.createdBy ||
        request.auth.uid in resource.data.moderatorIds
      );
    }

    // FORUM MESSAGES
    match /forum_messages/{messageId} {
      allow read: if true; // Anyone can read messages
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      // Allow update: message owner, moderators (for pinning), or forum creator
      allow update: if request.auth != null && (
        request.auth.uid == resource.data.userId ||
        request.auth.uid in get(/databases/$(database)/documents/forums/$(resource.data.forumId)).data.moderatorIds ||
        request.auth.uid == get(/databases/$(database)/documents/forums/$(resource.data.forumId)).data.createdBy ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions'])
      );
      // Allow delete: message owner, forum moderators, OR forum creator
      allow delete: if request.auth != null && (
        request.auth.uid == resource.data.userId ||
        request.auth.uid in get(/databases/$(database)/documents/forums/$(resource.data.forumId)).data.moderatorIds ||
        request.auth.uid == get(/databases/$(database)/documents/forums/$(resource.data.forumId)).data.createdBy
      );
    }

    // FORUM MEMBERS
    match /forum_members/{memberId} {
      // memberId format: "{forumId}_{userId}"
      allow read: if true;
      allow create: if request.auth != null && memberId.matches('.*_' + request.auth.uid + '$');
      allow update: if request.auth != null && (
        memberId.matches('.*_' + request.auth.uid + '$') ||
        request.auth.uid in get(/databases/$(database)/documents/forums/$(request.resource.data.forumId)).data.moderatorIds
      );
      // Allow delete by user themselves OR forum moderators (for cascade delete)
      allow delete: if request.auth != null;
    }

    // USER FORUM SUBSCRIPTIONS
    match /user_forums/{subscriptionId} {
      // subscriptionId format: "{userId}_{forumId}"
      // Allow read for own subscriptions OR when listing for forum deletion (moderator)
      allow read: if request.auth != null;
      allow create: if request.auth != null && subscriptionId.matches('^' + request.auth.uid + '_.*');
      allow update: if request.auth != null && subscriptionId.matches('^' + request.auth.uid + '_.*');
      // Allow delete by user themselves OR forum moderators (for cascade delete)
      allow delete: if request.auth != null;
    }
  }
}
